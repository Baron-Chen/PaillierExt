using System;
using System.Security.Cryptography;
using System.Text;
using System.Xml;

namespace PaillierExt
{
    public enum PaillierPaddingMode : byte
    {
        ANSIX923,
        LeadingZeros,
        Zeros
    };

    public abstract class Paillier : AsymmetricAlgorithm
    {

        public PaillierPaddingMode Padding;

        public abstract void ImportParameters(PaillierParameters p_parameters);
        public abstract PaillierParameters ExportParameters(bool p_include_private_params);
        public abstract byte[] EncryptData(byte[] p_data);
        public abstract byte[] DecryptData(byte[] p_data);
        public abstract byte[] Sign(byte[] p_hashcode);
        public abstract bool VerifySignature(byte[] p_hashcode, byte[] p_signature);

        public abstract byte[] Addition(byte[] p_first, byte[] p_second);

        public override string ToXmlString(bool p_include_private)
        {
            PaillierParameters x_params = ExportParameters(p_include_private);
            // create a new string builder
            StringBuilder x_sb = new StringBuilder();
            // add the header
            x_sb.Append("<PaillierKeyValue>");
            // add the public elements from the parameters
            x_sb.Append("<N>" + Convert.ToBase64String(x_params.N) + "</N>");
            x_sb.Append("<G>" + Convert.ToBase64String(x_params.G) + "</G>");
            //x_sb.Append("<Padding>" + Padding.ToString() + "</Padding>");
            x_sb.Append("<Padding>" + x_params.Padding.ToString() + "</Padding>");

            if (p_include_private)
            {
                // we need to include X, which is the part of private key
                x_sb.Append("<Lambda>" + Convert.ToBase64String(x_params.Lambda) + "</Lambda>");
                x_sb.Append("<Miu>" + Convert.ToBase64String(x_params.Miu) + "</Miu>");
            }
            // add the final element
            x_sb.Append("</PaillierKeyValue>");
            return x_sb.ToString();
        }

        public override void FromXmlString(String p_string)
        {
            // create the params that we will use as the result
            PaillierParameters x_params = new PaillierParameters();
            // create a text reader using a string reader
            XmlTextReader x_reader =
                new XmlTextReader(new System.IO.StringReader(p_string));

            // run through the elements in the xml string
            while (x_reader.Read())
            {
                // we are only interested in processing start nodes
                if (true || x_reader.IsStartElement())
                {
                    switch (x_reader.Name)
                    {
                        case "N":
                            // set the value for N
                            x_params.N = Convert.FromBase64String(x_reader.ReadString());
                            break;
                        case "G":
                            // set the value for G
                            x_params.G = Convert.FromBase64String(x_reader.ReadString());
                            break;
                        case "Padding":
                            // set the padding mode
                            x_params.Padding = (PaillierPaddingMode)Enum.Parse(typeof(PaillierPaddingMode), x_reader.ReadString());
                            break;
                        case "Lambda":
                            // set the value for Lambda (this would not be found in a 
                            // string that was generated by excluding the private
                            // elements.
                            x_params.Lambda = Convert.FromBase64String(x_reader.ReadString());
                            break;
                        case "Miu":
                            // set the value for Lambda (this would not be found in a 
                            // string that was generated by excluding the private
                            // elements.
                            x_params.Miu = Convert.FromBase64String(x_reader.ReadString());
                            break;
                    }
                }
            }
            // Import the result
            ImportParameters(x_params);
        }
    }

}
